/* Original code Copyright (c) 2013 Chris Underwood[1]
   Modified code Copyright (c) 2016 Shane Celis[2]

   Original code posted here[3].

   This comment generated by code-cite[4].

   NOTE: Modified by Shane Celis to do a wave.

   [1]: http://deeperbeige.com
   [2]: http://twitter.com/shanecelis
   [3]: https://bitbucket.org/AcornGame/adjustable-character-spacing/src
   [4]: https://github.com/shanecelis/code-cite
*/
/*
  Based off of Adjustable Character Spacing, a free Unity script, originally
  written by Chris Underwood (Deeperbeige).

  Modified by Andrew Pavlovich.
  https://bitbucket.org/AcornGame/adjustable-character-spacing/src

  Modified by Shane Celis to do a wave.
*/
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;

/*
  Produces an simple tracking/letter-spacing effect on UI Text components.

  Set the spacing parameter to adjust letter spacing.
  Negative values cuddle the text up tighter than normal. Go too far and it'll look odd.
  Positive values spread the text out more than normal. This will NOT respect the text area you've defined.
  Zero spacing will present the font with no changes.

  Relies on counting off characters in your Text component's text property and
  matching those against the quads passed in via the verts array. This is really
  rather primative, but I can't see any better way at the moment. It means that
  all sorts of things can break the effect...

  This component should be placed higher in component list than any other vertex
  modifiers that alter the total number of verticies. Eg, place this above Shadow
  or Outline effects. If you don't, the outline/shadow won't match the position
  of the letters properly. If you place the outline/shadow effect second however,
  it will just work on the altered vertices from this component, and function
  as expected.

  This component works best if you don't allow text to automatically wrap. It also
  blows up outside of the given text area. Basically, it's a cheap and dirty effect,
  not a clever text layout engine. It can't affect how Unity chooses to break up
  your lines. If you manually use line breaks however, it should detect those and
  function more or less as you'd expect.

  The spacing parameter is measured in pixels multiplied by the font size. This was
  chosen such that when you adjust the font size, it does not change the visual spacing
  that you've dialed in. There's also a scale factor of 1/100 in this number to
  bring it into a comfortable adjustable range. There's no limit on this parameter,
  but obviously some values will look quite strange.

  This component doesn't really work with Rich Text. You don't need to remember to
  turn off Rich Text via the checkbox, but because it can't see what makes a
  printable character and what doesn't, it will typically miscount characters when you
  use HTML-like tags in your text. Try it out, you'll see what I mean. It doesn't
  break down entirely, but it doesn't really do what you'd want either.

*/

namespace UnityEngine.UI
{

[System.Serializable]
public class WaveParameters {
  public float startOfWave;
  public Vector3 position;
  public float amplitude;
  public float speed;
  public float waveLength;
}
[AddComponentMenu("UI/Effects/Letter Rumble", 14)]
#if UNITY_5_2 || UNITY_5_3 || UNITY_5_3_OR_NEWER
public class LetterRumble : BaseMeshEffect
#else
public class LetterRumble : BaseVertexEffect
#endif
{
  //[SerializeField]
  private float m_spacing = 0f;
  public WaveParameters defaultWaveParams;
  public WaveParameters minWaveParams;
  public WaveParameters maxWaveParams;
  private List<WaveParameters> waves = new List<WaveParameters>();
  public float jiggleAmplitude = 0f;
  public float maxWaveHeight = 1f;

  public bool waveDissipates = false;
  public float maxAreaOfEffect = 100f;
  public float chunkSize = -1f;
  protected LetterRumble() { }

  #if UNITY_EDITOR
  protected override void OnValidate()
  {
    spacing = m_spacing;
    base.OnValidate();
  }
  #endif

  public float spacing
  {
    get { return m_spacing; }
    set {
      if (m_spacing == value)
        return;
      m_spacing = value;
      if (graphic != null)
        graphic.SetVerticesDirty();
    }
  }

  void Update() {
    // if (Input.GetMouseButtonDown(0)) {
    //   StartWave(Input.mousePosition);
    // }

    if (waves.Count != 0)
      GetComponent<Text>().SetVerticesDirty();
    // Remove excess waves.
    if (waves.Any(w => (Time.time - w.startOfWave) > 10f))
      waves = waves.Where(w => (Time.time - w.startOfWave) < 10f).ToList();
  }

  #if UNITY_5_2 || UNITY_5_3 || UNITY_5_3_OR_NEWER
  public void ModifyVertices(List<UIVertex> verts)
    #else
    public override void ModifyVertices(List<UIVertex> verts)
    #endif
  {
    if (! IsActive()) return;

    Text text = GetComponent<Text>();
    if (text == null)
    {
      Debug.LogWarning("LetterSpacing: Missing Text component");
      return;
    }

    string[] lines = text.text.Split('\n');
    //Vector3  pos;
    //float    letterOffset    = spacing * (float)text.fontSize / 100f;
    //float    alignmentFactor = 0;
    int      glyphIdx        = 0;


    //float minY = verts.Select(v => v.position.y).Min();
    //float minX = verts.Select(v => v.position.x).Min();
    for (int lineIdx=0; lineIdx < lines.Length; lineIdx++)
    {
      string line = lines[lineIdx];
      //float lineOffset = (line.Length -1) * letterOffset * alignmentFactor;

      for (int charIdx = 0; charIdx < line.Length; charIdx++)
      {
        int idx1 = glyphIdx * 6 + 0;
        int idx2 = glyphIdx * 6 + 1;
        int idx3 = glyphIdx * 6 + 2;
        int idx4 = glyphIdx * 6 + 3;
        int idx5 = glyphIdx * 6 + 4;
        int idx6 = glyphIdx * 6 + 5;

        // Check for truncated text (doesn't generate verts for all characters)
        if (idx4 > verts.Count - 1) return;

        UIVertex vert1 = verts[idx1];
        UIVertex vert2 = verts[idx2];
        UIVertex vert3 = verts[idx3];
        UIVertex vert4 = verts[idx4];
        UIVertex vert5 = verts[idx5];
        UIVertex vert6 = verts[idx6];

        //pos = Vector3.right * (letterOffset * charIdx - lineOffset)
        //                      + Vector3.up * 10 * Mathf.Sin(Mathf.PI * Time.time + vert1.position.x);
        //pos = Vector3.up * 10 * Wave(vert1.position.x, Time.time, 1, 10);
        //pos = ComputeOffset(vert1.position);
        // if (false) {
        //   vert1.position += pos;
        //   vert2.position += pos;
        //   vert3.position += pos;
        //   vert4.position += pos;
        //   vert5.position += pos;
        //   vert6.position += pos;
        // } else {
          vert1.position += ComputeOffset(vert1.position);
          vert2.position += ComputeOffset(vert2.position);
          vert3.position += ComputeOffset(vert3.position);
          vert4.position += ComputeOffset(vert4.position);
          vert5.position += ComputeOffset(vert5.position);
          vert6.position += ComputeOffset(vert6.position);
        //}

        verts[idx1] = vert1;
        verts[idx2] = vert2;
        verts[idx3] = vert3;
        verts[idx4] = vert4;
        verts[idx5] = vert5;
        verts[idx6] = vert6;

        glyphIdx++;
      }

      // Offset for carriage return character that still generates verts
      glyphIdx++;
    }
  }

  private float Chunk(float x, float chunkSize) {
    return Mathf.Floor(x/chunkSize) * chunkSize;
  }

  Vector3 ComputeOffset(Vector3 v) {
    var pos = Vector3.zero;
    foreach(var waveParams in waves) {
      var p = transform.InverseTransformPoint(waveParams.position);
      //var p = waveParams.position;
      //print(vert1.position);
      var waveHeight =
        waveParams.amplitude
        * Wave(Mathf.Abs(v.x - p.x),
               Time.time - waveParams.startOfWave,
               waveParams.speed,
               waveParams.waveLength);
      if (waveDissipates)
        waveHeight *= TriangleBasis(v.x - p.x, maxAreaOfEffect);

      pos += Vector3.up
        * waveHeight;
      //* jiggleAmplitude;
    }
    var y = Mathf.Min(maxWaveHeight, pos.y);
    if (chunkSize > 0f)
      y = Chunk(y, chunkSize);
    return new Vector3(pos.x, y, pos.z);
    //return pos;
  }

  /*
    Height of triangle basis function centered on 0 with a base lenght of b at x.
  */
  private float TriangleBasis(float x, float b = 1) {
    if (x < 0)
      return Mathf.Max(0f, 2f / b * x + 1f);
    else
      return Mathf.Max(0f, 1f - 2f / b * x);
  }

  //private float

  /*
    Returns wave height at point p and time t with a speed of w and wave
    length of lambda.
  */
  private float Wave(float p, float t, float w = 1, float lambda = 1) {
    return TriangleBasis(p + lambda / 2f - w * t, lambda);
  }

  public void StartWave(Vector3 position) {
    StartWave(position,
              defaultWaveParams.amplitude,
              defaultWaveParams.speed,
              defaultWaveParams.waveLength);
  }

  public void StartWaveRandom(Vector3 position) {
    StartWave(position,
              Random.Range(minWaveParams.amplitude, maxWaveParams.amplitude),
              Random.Range(minWaveParams.speed, maxWaveParams.speed),
              Random.Range(minWaveParams.waveLength, maxWaveParams.waveLength));
  }

  public void StartWave(Vector3 position, float amplitude, float speed, float waveLength) {
    var waveParams = new WaveParameters();
    waveParams.startOfWave = Time.time;
    waveParams.position = position;
    waveParams.amplitude = amplitude;
    waveParams.speed = speed;
    waveParams.waveLength = waveLength;
    // We could add some speed to the previous waves so that they don't bunch up.
    // foreach (var w in waves)
    //   w.speed *= 1.2f;
    waves.Add(waveParams);
  }


  #if UNITY_5_2
  public override void ModifyMesh(Mesh mesh)
  {
    if (!this.IsActive())
      return;

    List<UIVertex> list = new List<UIVertex>();
    using (VertexHelper vertexHelper = new VertexHelper(mesh))
    {
      vertexHelper.GetUIVertexStream(list);
    }

    ModifyVertices(list);  // calls the old ModifyVertices which was used on pre 5.2

    using (VertexHelper vertexHelper2 = new VertexHelper())
    {
      vertexHelper2.AddUIVertexTriangleStream(list);
      vertexHelper2.FillMesh(mesh);
    }
  }
  #elif UNITY_5_3 || UNITY_5_3_OR_NEWER
  public override void ModifyMesh(VertexHelper vh)
  {
    if (!this.IsActive())
      return;

    List<UIVertex> vertexList = new List<UIVertex>();
    vh.GetUIVertexStream(vertexList);

    ModifyVertices(vertexList);

    vh.Clear();
    vh.AddUIVertexTriangleStream(vertexList);
  }
  #endif
}


}
