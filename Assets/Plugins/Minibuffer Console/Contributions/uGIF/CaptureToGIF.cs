/* Original code Copyright (c) 2015 Simon Wittber[1]
   Modified code Copyright (c) 2016 Shane Celis[2]
   Licensed under the MIT License[3]

   Original code posted here[4].

   This comment generated by code-cite[5].

   NOTE: Modified for use with Minibuffer.

   [1]: https://github.com/simonwittber
   [2]: http://twitter.com/shanecelis
   [3]: https://opensource.org/licenses/MIT
   [4]: https://github.com/simonwittber/uGIF
   [5]: https://github.com/shanecelis/code-cite
*/
using UnityEngine;
using System.Collections;
using System.IO;
using System.Linq;
using System.Collections.Generic;

using System.Threading;
using SeawispHunter.MinibufferConsole.Extensions;

using SeawispHunter.MinibufferConsole;
using RSG;

namespace uGIF
{

/**
   ![GIF commands in the inspector](inspector/capture-to-gif.png)
   Record a GIF.

   In the settings, one can juggle between quickly encoded GIFs with palettes
   that may miss some colors, or slowly encoded GIFs with more comprehensive
   palettes.  These settings must be chosen on a game-by-game basis.
 */
[Group(tag = "built-in")]
public class CaptureToGIF : MonoBehaviour
{
  public float frameRate = 15;
  [Header("Stop recording a GIF that's longer than this many seconds")]
  public float maxCaptureTime = 30; // seconds
  [Range(1, 4)]
  public int downscale = 1;
  public bool useBilinearScaling = true;
  [Header("Color Palette Options")]
  public bool useGlobalColorTable = true;
  [Header("Number of frames to sample constructing global color palette")]
  [Tooltip("1 -> sample first frame; 2 -> first and last; 3 -> first, middle, last, and so on")]
  public int sampleFrames = 2;
  [Header("Quality of color sampling; lower is slower but better quality")]
  [Range(1, 100)]
  public int quality = 10;
  [Header("Directory to store GIFs. Left unset will ask user.")]
  public string gifDirectory;
  public MinibufferListing minibufferExtensions;
  public Promise<string> gifFile = new Promise<string>();
  public string lastGifFilename { get; set; }

  [System.NonSerialized]

  internal bool capturing;
  private bool encoding;
  private bool aborted;
  private Rect gameRect;

  void Start ()
  {
    period = 1f / frameRate;
    Minibuffer.Register(this);
  }

  void OnDestroy ()
  {
    Minibuffer.Unregister(this);
  }

  [Command("gif-record", keyBinding = "C-[", description = "Start recording a GIF.")]
  public string GIFRecord()
  {
    if (capturing) {
      return "Already recording GIF.";
    }
    if (encoding) {
      return "Currently encoding a GIF.";
    }
    if (gifDirectory.IsZull()) {
      // No directory set. Ask for one the first time.
      // var promise =
      Minibuffer.instance
        .Read("GIF directory: ", // prompt
              "~",               // input
              "gif-directory",   // history
              "directory"        // completer
              )
        .Then((path) => {
            gifDirectory = (string) path;
            Minibuffer.instance.WithCommandResult(GIFRecord());
          })
        .Catch(ex => { }); // Don't care.
      return null;
    }
    gameRect = GetGameRect();
    // print ("gameRect " + gameRect);
    colorBuffer = new Texture2D ((int) gameRect.width, (int) gameRect.height, TextureFormat.RGB24, false, true);
    renderTexture = new RenderTexture((int) gameRect.width, (int) gameRect.height, 24);
    startTime = Time.time;
    capturing = true;
    aborted = false;
    // maxCaptureTime = -1;
    StartCoroutine(CaptureFrames());
    return "Start GIF recording.";
  }

  [Command("gif-stop", keyBinding = "C-]", description = "Stop recording a GIF and encode it.")]
    public IEnumerator GIFStop()
  {
    if (! capturing) {
      Minibuffer.instance.Message("Not recording a GIF yet.");
      yield break;
    }
    Minibuffer.instance.Message("Stop GIF recording. Encoding...");
    yield return new WaitForSeconds(1f);
    capturing = false;
  }

  [Command("gif-cancel", description = "Cancel GIF recording.")]
  public string GIFCancel() {
    if (! capturing) {
      return "Not currently capturing a GIF.";
    }
    if (encoding) {
      return "Currently encoding a GIF.";
    }
    aborted = true;
    capturing = false;
    return "Canceled GIF capture.";
  }

  // Could have a cancel, and an ability to stop, start and finish.
  // [Command("gif-cancel", keyBinding = "C-]")]
  // public void GIFCancel() {
  // }

  public void Encode ()
  {
    // print("start encoding");
    encoding = true;
    this.RunInThread<byte[]>(() => _Encode())
      .Then(bytes => {
          var filename = UnityCommands.GenerateNewFilename(PathName.instance
                                                           .Expand(Path.Combine(gifDirectory,
                                                                   "movie-{0}.gif")));

          System.IO.File.WriteAllBytes(filename, bytes);
          Minibuffer.instance.Message("Encoding complete. Wrote GIF to {0}",
                                      PathName.instance.Compress(filename));
          gifFile.Resolve(filename);
          lastGifFilename = filename;
          gifFile = new Promise<string>();
        })
      .Catch(ex => {
          gifFile.Reject(ex);
          gifFile = new Promise<string>(); })
      // .Finally(() => { gifFile = new Promise<string>(); })
      .Done();
  }

  private byte[] _Encode ()
  {
    capturing = false;
    var ge = new GIFEncoder ();
    ge.useGlobalColorTable = useGlobalColorTable;
    ge.repeat = 0;
    ge.FPS = frameRate;
    ge.transparent = new Color32 (255, 0, 255, 255);
    ge.dispose = 1;
    ge.quality = quality;
    if (sampleFrames > 1) {
      sampleFrames = sampleFrames.Min(frames.Count);

      int spacing = frames.Count / (sampleFrames - 1);
      var samples = Enumerable.Range(0, sampleFrames)
        .Select(x => frames[(x * spacing).Clamp(0, frames.Count - 1)]);
      // print("Using " + samples.Count() + " samples");
      ge.BuildPalette(samples);
    }

    var stream = new MemoryStream ();
    ge.Start (stream);
    foreach (var f in frames) {
      if (downscale != 1) {
        if(useBilinearScaling) {
          f.ResizeBilinear(f.width/downscale, f.height/downscale);
        } else {
          f.Resize (downscale);
        }
      }
      f.Flip ();
      ge.AddFrame (f);
    }
    ge.Finish ();
    var bytes = stream.GetBuffer ();
    stream.Close ();
    frames.Clear ();
    encoding = false;
    return bytes;
    // print("end encoding");
  }

  IEnumerator CaptureFrames ()
  {
    var wait = new WaitForSeconds(period);
    yield return new WaitForEndOfFrame();
    while (capturing) {
      // http://answers.unity3d.com/questions/27968/getpixels-of-rendertexture.html
      var oldTargetTexture = Camera.main.targetTexture;
      var oldActiveRT = RenderTexture.active;
      Camera.main.targetTexture = renderTexture;
      Camera.main.Render();
      RenderTexture.active = renderTexture;
      colorBuffer.ReadPixels (gameRect, 0, 0, false);
      Camera.main.targetTexture = oldTargetTexture;
      RenderTexture.active = oldActiveRT;
      // colorBuffer.Apply();
      frames.Add (new Image (colorBuffer));

      if (maxCaptureTime > 0 && Time.time > (startTime + maxCaptureTime)) {
        capturing = false;
      } else {
        yield return wait;
        yield return new WaitForEndOfFrame();
      }
    }
    if (! capturing && ! encoding && ! aborted && frames.Any()) {
      Encode ();
    }
    if (aborted) {
      frames.Clear();
      gifFile.Reject(new AbortException("GIF capture canceled."));
      gifFile = new Promise<string>();
    }
  }

  // void OnPostRender ()
  // // void LateUpdate ()
  // // void OnRenderImage ()
  // {
  //    if (capturing) {
  //      T += Time.deltaTime;
  //      if (T >= period) {
  //        T = 0;
  //        colorBuffer.ReadPixels (gameRect, 0, 0, false);
  //       colorBuffer.Apply();
  //        frames.Add (new Image (colorBuffer));
  //      }
  //     if (maxCaptureTime > 0 && Time.time > (startTime + maxCaptureTime)) {
  //       capturing = false;
  //     }
  //    }
  //   if (! capturing && ! encoding && frames.Any()) {
  //     Encode ();
  //   }
  // }

  // http://answers.unity3d.com/questions/1084793/how-can-i-avoid-texture2d-readpixels-capturing-non.html
  #if UNITY_EDITOR
  private static System.Reflection.FieldInfo s_MainGameViewRect = null;
  public static Rect GetGameRect()
  {
    if (s_MainGameViewRect == null) {
      var gameView = typeof(UnityEditor.EditorWindow).Assembly.GetTypes().Where(a => a.Name == "GameView").FirstOrDefault();
      s_MainGameViewRect = gameView.GetField("s_MainGameViewRect", System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic);
    }
    // This reflection trick doesn't work in later versions of Unity.
    if (s_MainGameViewRect == null)
      return new Rect(0, 0, Screen.width, Screen.height);
    Rect r = (Rect)s_MainGameViewRect.GetValue(null);
    r.y -= 17;
    return r;
  }
  #else
  public static Rect GetGameRect()
  {
    return new Rect(0, 0, Screen.width, Screen.height);
  }
  #endif


  List<Image> frames = new List<Image> ();
  /*public*/ Texture2D colorBuffer;
  float period;
  // float T = 0;
  float startTime = 0;
  RenderTexture renderTexture;

}
}
