/* Original code Copyright (c)  [1]
   Modified code Copyright (c) 2016 Shane Celis[2]

   Original code posted here[3].

   This comment generated by code-cite[4].

   NOTE: Donated: https://twitter.com/joeld42/status/852995275073347584

   [1]: https://twitter.com/joeld42
   [2]: http://twitter.com/shanecelis
   [3]: https://twitter.com/joeld42/status/852994871195451392
   [4]: https://github.com/shanecelis/code-cite
*/
using System;
using System.IO;

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using SeawispHunter.MinibufferConsole;
using SeawispHunter.MinibufferConsole.Extensions;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace SeawispHunter.MinibufferConsole {

public struct SVGTriangle
{
  // triangle verts in screen space
  public Vector3 a;
  public Vector3 b;
  public Vector3 c;

  public float zdepth;

  public Color color;
}

// [ExecuteInEditMode]
/**
   ![SVG commands in the inspector](inspector/svg-commands.png)
   Create an Scalable Vector Graphic (SVG) of an object.

   ![Fig 1. Quadrapus in game](svg-screenshot-1.jpg)
   ![Fig 2. SVG of quadrapus](svg-screenshot-2.jpg)
   For example, figure 1 shows a Quadrapus from the demo scene. Figure 2, shows what the generated SVG file looks like this.

   This fancy feature was created by [Joel Davis](https://twitter.com/joeld42)
   for [KennyNL](https://twitter.com/KenneyNL), known as "Asset Jesus" and
   produces [amazing assets](https://kenney.nl/assets). Thank you, Joel, for
   [donating it](https://twitter.com/joeld42/status/852995275073347584)! And
   thank you, Kenny, for all the great assets!
 */
[Group(tag = "built-in")]
public class SVGScreenshot : MonoBehaviour {

  public enum Stroke {
    Stroke_NONE,
    Stroke_MATCH_FILL, // Match fill, helps hide cracks
    Stroke_BLACK, // Solid black
  }

  private Transform target;
  public Stroke stroke = Stroke.Stroke_MATCH_FILL;
  public string screenshotDirectory = "~/Desktop";
  private string outputFilename;
  public bool openFileAfter = false;

  private bool doCapture = false;
  public MinibufferListing minibufferExtensions;
  // public bool skipEvenStrokes = false;

  // Use this for initialization
  void Start () {
    Minibuffer.Register(this);
  }

  // Update is called once per frame
  void Update () {
  }

  void OnDestroy() {
    Minibuffer.Unregister(this);
  }

  void OnPostRender() {
    if (doCapture) {
      doCapture = false;

      DoTakeScreenshot ();
    }
  }

  private Vector3 ScreenSpace( Camera cam, Vector3 pnt )
  {
    Vector3 result = cam.WorldToScreenPoint (pnt);
    result.y = cam.pixelHeight - result.y;
    return result;
  }

  private void GatherTriangles( Transform xform, List<SVGTriangle> svgTris, Camera cam )
  {
    Matrix4x4 localToWorld = xform.localToWorldMatrix;

    // Gather triangles from meshes in this object
    MeshFilter meshFilter = xform.gameObject.GetComponent<MeshFilter>();
    if (meshFilter != null) {
      Mesh mesh = meshFilter.sharedMesh;
      if (mesh != null) {
        #if UNITY_5_4_OR_NEWER
        List<Vector3> verts = new List<Vector3> ();
        mesh.GetVertices (verts);
        #else
        var verts = mesh.vertices;
        #endif
        for (int i = 0; i < mesh.subMeshCount; i++) {
          int[] tris = mesh.GetTriangles (i);

          //Debug.Log (string.Format ("submesh {0} tris {1}", i, tris.Length));
          for (int j = 0; j < tris.Length / 3; j++) {
            SVGTriangle ssTri = new SVGTriangle ();

            ssTri.a = ScreenSpace (cam, localToWorld.MultiplyPoint(verts [tris [j * 3 + 0]]) );
            ssTri.b = ScreenSpace (cam, localToWorld.MultiplyPoint(verts [tris [j * 3 + 1]]) );
            ssTri.c = ScreenSpace (cam, localToWorld.MultiplyPoint(verts [tris [j * 3 + 2]]) );

            // Check if it's backfacing
            Vector3 ab = new Vector3( ssTri.b.x - ssTri.a.x, ssTri.b.y - ssTri.a.y, 0.0f );
            Vector3 bc = new Vector3( ssTri.c.x - ssTri.b.x, ssTri.c.y - ssTri.b.y, 0.0f );
            Vector3 facing = Vector3.Cross (ab, bc);
            if (facing.z > 0.0) {

              //ssTri.zdepth = (ssTri.a.z + ssTri.b.z + ssTri.c.z) / 3.0f;
              ssTri.zdepth = Mathf.Max( ssTri.a.z, Mathf.Max(ssTri.b.z, ssTri.c.z) );

              ssTri.color = Color.HSVToRGB (UnityEngine.Random.value, 1.0f, 0.7f);
              svgTris.Add (ssTri);
            }

          }
        }
      }
    }


    // Gather triangles from any child meshes
    foreach (Transform child in xform) {
      GatherTriangles (child, svgTris, cam );
    }
  }


  private void OutputSVGFile( string svgfilename, Camera cam, List<SVGTriangle> svgTris )
  {
    using (StreamWriter sw = new StreamWriter (svgfilename)) {
      // Header
      sw.Write("<svg width=\"{0}\" height=\"{1}\">\n", cam.pixelWidth, cam.pixelHeight );

      foreach (SVGTriangle tri in svgTris) {
        string colorHex = string.Format ("{0:X2}{1:X2}{2:X2}",
                                         (byte)(Mathf.Clamp01 (tri.color.r) * 0xff),
                                         (byte)(Mathf.Clamp01 (tri.color.g) * 0xff),
                                         (byte)(Mathf.Clamp01 (tri.color.b) * 0xff));

        string strokeText = "";
        switch (stroke) {
          case Stroke.Stroke_BLACK:
            strokeText = "stroke=\"#000000\"";
            break;

          case Stroke.Stroke_MATCH_FILL:
            strokeText = "stroke=\"#" + colorHex + "\"";
            break;

          case Stroke.Stroke_NONE:
            break;
        }

        // XXX Might be nice to add someday.
        // if (skipEvenStrokes && stroke != Stroke.Stroke_NONE) {

        //   sw.Write("  <polygon points=\"{0},{1}  {2},{3} {4},{5}\" fill=\"#{6}\"/>\n",
        //            tri.a.x, tri.a.y,
        //            tri.b.x, tri.b.y,
        //            tri.c.x, tri.c.y,
        //            colorHex, strokeText );

        //   sw.Write("  <polyline points=\"{0},{1}  {2},{3} {4},{5}\" fill=\"none\" {7}/>\n",
        //            tri.b.x, tri.b.y,
        //            tri.c.x, tri.c.y,
        //            tri.a.x, tri.a.y,
        //            colorHex, strokeText);

        // } else {
        sw.Write("  <polygon points=\"{0},{1}  {2},{3}  {4},{5}\" fill=\"#{6}\" {7} />\n",
                 tri.a.x, tri.a.y,
                 tri.b.x, tri.b.y,
                 tri.c.x, tri.c.y,
                 colorHex, strokeText );
        // }
      }

      sw.Write ("</svg>\n");
    }
  }

  [Command("svg-screenshot",
           description = "Render a target object to an SVG file.")]
  public void ScreenshotCommand([Prompt("SVG target object: ",
                                        history = "gameobject-svg")]
                                GameObject go) {
    if (screenshotDirectory.IsZull()) {
      // No directory set. Ask for one the first time.
      Minibuffer.instance
        .Read("Screenshot directory: ", // prompt
              "~",                      // input
              "screenshot-directory",   // history
              "directory"               // completer
              )
        .Then((path) => {
            screenshotDirectory = (string) path;
            // Then capture the screenshot.
            ScreenshotCommand(go);
          })
        .Catch(ex => { }); // Don't care.
    } else {
      var filename = UnityCommands.GenerateNewFilename(screenshotDirectory
                                                       + "screenshot-{0}.svg");
      target = go.transform;
      doCapture = true;
      outputFilename = filename;
    }
  }

  private void DoTakeScreenshot()
  {
    Camera ssCam = Camera.main;

    // Create a texture the size of the screen, RGB24 format
    int width = Screen.width;
    int height = Screen.height;
    Texture2D tex = new Texture2D(width, height, TextureFormat.RGB24, false);

    // Read screen contents into the texture
    tex.ReadPixels(new Rect(0, 0, width, height), 0, 0);
    tex.Apply();

    // (for debugging) Encode texture into PNG
    //      byte[] bytes = tex.EncodeToPNG();
    //
    //      // For testing purposes, also write to a file in the project folder
    //      //File.WriteAllBytes(Application.dataPath + "/../SavedScreen.png", bytes);
    //      File.WriteAllBytes("SavedScreenPostRender.png", bytes);

    List<SVGTriangle> svgTris = new List<SVGTriangle> ();
    GatherTriangles (target, svgTris, ssCam);

    //  depth sort triangles
    svgTris.Sort((x,y) => y.zdepth.CompareTo(x.zdepth));

    // Apply colors from screen capture
    for (int triIndex = 0; triIndex < svgTris.Count; triIndex++) {
      SVGTriangle tri = svgTris [triIndex];
      Vector3 center = (tri.a + tri.b + tri.c) / 3.0f;
      tri.color = tex.GetPixel ((int)center.x, tex.height - (int)center.y);
      svgTris [triIndex] = tri;
    }

    string svgName = outputFilename ?? target.name +  ".svg";
    OutputSVGFile(svgName, ssCam, svgTris);

    outputFilename = null;

    DestroyImmediate(tex);
    // Debug.Log ("--- Saved SVG: " + svgName + " ---" );
    Minibuffer.instance.Message("Wrote SVG file: {0}", svgName);
    if (openFileAfter)
      Open.Path(svgName);
  }

  public void RequestScreenshot( )
  {
    // set to capture in next postrender...
    doCapture = true;
  }


}

#if UNITY_EDITOR
[CustomEditor(typeof(SVGScreenshot))]
public class SVGScreenshotEditor : Editor
{
  void OnEnable()
  {
  }

  public override void OnInspectorGUI()
  {
    DrawDefaultInspector ();

    if (GUILayout.Button ("Take Screenshot")) {
      if (!EditorApplication.isPlaying) {
        EditorUtility.DisplayDialog ("SVG Screenshot",
                                     "You must be in Play mode for this to work",
                                     "I see.");
      } else {
        SVGScreenshot screenshotHelper = (SVGScreenshot)target;
        screenshotHelper.RequestScreenshot ();
      }
    }
  }
}
#endif
}
