/* Original code Copyright (c) 2015 SnapStreamJason[1]
   Modified code Copyright (c) 2016 Shane Celis[2]
   Licensed under the Apache License v2.0[3]

   Original code posted here[4].

   This comment generated by code-cite[5].

   NOTE: Added authorization code and fixed to work with Unity.

   [1]: https://github.com/SnapStreamJason
   [2]: http://twitter.com/shanecelis
   [3]: https://www.apache.org/licenses/LICENSE-2.0
   [4]: https://github.com/SnapStreamJason/TinyTwitter
   [5]: https://github.com/shanecelis/code-cite
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
// using UnityEngine;
using SeawispHunter.FullSerializer;
using SeawispHunter.MinibufferConsole;

namespace Tiny.Twitter
{

public class OAuthInfo
{
  public string ConsumerKey { get; set; }
  public string ConsumerSecret { get; set; }
  public string AccessToken { get; set; }
  public string AccessSecret { get; set; }
}

public class AccessInfo
{
  public OAuthInfo oauth { get; set; }
  public User user;
}

[System.Serializable]
[fsObject("v1")]
public class User
{
  public long id { get; set; }
  public string name { get; set; }
  [fsProperty("screen_name")]
  public string screenName { get; set; }
}

[System.Serializable]
[fsObject("v1")]
public class Tweet
{
  public long id { get; set; }
  [fsProperty("created_at", Converter = typeof(TwitterDateTimeConverter))]
  public DateTime createdAt { get; set; }
  public User user { get; set; }
  public string text { get; set; }
}
[System.Serializable]
[fsObject("v1")]
public class ChunkedInitResult
{
  public long media_id { get; set; }
  public string media_id_string { get; set; }
  public int expires_after_secs { get; set; }
}
public class TinyTwitter
{
  private readonly OAuthInfo oauth;

  public TinyTwitter(OAuthInfo oauth)
  {
    this.oauth = oauth;
  }

  public void UpdateStatus(string message)
  {
    new RequestBuilder(oauth, "POST", "https://api.twitter.com/1.1/statuses/update.json")
      .AddParameter("status", message)
      .Execute();
  }

  public IEnumerable<Tweet> GetHomeTimeline(long? sinceId = null, long? maxId = null, int? count = null)
  {
    if (! count.HasValue)
      count = 20;
    return GetTimeline("https://api.twitter.com/1.1/statuses/home_timeline.json", sinceId, maxId, count, "");
  }

  public IEnumerable<Tweet> GetMentions(long? sinceId = null, long? maxId = null, int? count = null)
  {
    if (! count.HasValue)
      count = 20;
    return GetTimeline("https://api.twitter.com/1.1/statuses/mentions.json", sinceId, maxId, count, "");
  }

  public IEnumerable<Tweet> GetUserTimeline(long? sinceId = null, long? maxId = null, int? count = null, string screenName = "")
  {
    if (! count.HasValue)
      count = 20;
    return GetTimeline("https://api.twitter.com/1.1/statuses/user_timeline.json", sinceId, maxId, count, screenName);
  }

  public string UpdateStatusWithMedia( string message, string media )
  {
    //You can get a "The validation of media ids failed." error here when there was something wrong with the video encode
    //Upload succeeds, but then the actual status update fails. I believe there is an unstated MOOV before MDAT requirement on the files.
    string web = new RequestBuilder( oauth, "POST", "https://api.twitter.com/1.1/statuses/update.json" )
      .AddParameter( "status", message )
      .AddParameter( "media_ids", media )
      .Execute();
    return web;
  }

  public string UploadMedia( Stream file, string mediaType )
  {
    // Debug.Log("begin upload");
    // Make the initial request, this should get us the id we want to use
    string response = new RequestBuilder( oauth, "POST", "https://upload.twitter.com/1.1/media/upload.json" )
      .AddParameter( "command", "INIT" )
      .AddParameter( "media_type", mediaType )
      .AddParameter( "total_bytes", file.Length.ToString() )
      .Execute();

    // var serializer = new JavaScriptSerializer();
    // var initResult = serializer.Deserialize<ChunkedInitResult>( response );
    var initResult = StringSerializationAPI.Deserialize<ChunkedInitResult>(response);
    // var initResult = new ChunkedInitResult() { media_id_string = "hi", media_id = 1, expires_after_secs = 600 };
    // Debug.Log("finished INIT " + initResult.media_id_string);

    long pos = 0;
    long totalBytes = file.Length;
    int segment = 0;

    byte[] bytes = new byte[1 * 1024 * 1024];
    while( pos < totalBytes ) {
      // OMG. Do you really need to create all the buffers?
      //byte[] bytes = new byte[ Math.Min( 1 * 1024 * 1024, totalBytes - pos ) ];

      int bytesToRead = Math.Min(bytes.Length, (int) (totalBytes - pos));
      int totalBytesRead = 0;

      while( totalBytesRead < bytesToRead ) {
        int bytesRead = file.Read( bytes, totalBytesRead, bytesToRead - totalBytesRead );

        if( bytesRead == 0 ) {
          throw new Exception( "Read 0 bytes!" );
        }

        totalBytesRead += bytesRead;
      }

      // Debug.Log("APPEND attempt");
      response = new RequestBuilder( oauth, "POST", "https://upload.twitter.com/1.1/media/upload.json" )
        .AddParameter( "command", "APPEND" )
        .AddParameter( "media_id", initResult.media_id_string )
        .AddParameter( "segment_index", segment.ToString() )
        .MultipartExecute( bytes, 0, totalBytesRead );

      // Debug.Log("APPENDED");

      /*
       * Documentation doesn't mention this, but it seems to work. There's a Non multipart way
       * to upload a chunk. In this case all the parameters are used in the signature, not just the oauth_* ones
       *    web = new RequestBuilder( oauth, "POST", "https://upload.twitter.com/1.1/media/upload.json" )
       .AddParameter( "command", "APPEND" )
       .AddParameter( "media_id", initResult.media_id_string )
       .AddParameter( "segment_index", segment.ToString() )
       .AddParameter( "media_data", System.Convert.ToBase64String( bytes ) )
       .Execute();
       * */

      segment++;
      pos += bytes.Length;
    }

    response = new RequestBuilder( oauth, "POST", "https://upload.twitter.com/1.1/media/upload.json" )
      .AddParameter( "command", "FINALIZE" )
      .AddParameter( "media_id", initResult.media_id_string )
      .Execute();

    // Debug.Log("FINALIZED");
    return initResult.media_id_string;
  }

  private IEnumerable<Tweet> GetTimeline(string url, long? sinceId, long? maxId, int? count, string screenName)
  {
    var builder = new RequestBuilder(oauth, "GET", url);

    if (sinceId.HasValue)
      builder.AddParameter("since_id", sinceId.Value.ToString());

    if (maxId.HasValue)
      builder.AddParameter("max_id", maxId.Value.ToString());

    if (count.HasValue)
      builder.AddParameter("count", count.Value.ToString());

    if (screenName != "")
      builder.AddParameter("screen_name", screenName);

    var responseContent = builder.Execute();

    // Debug.Log("responseContent " + responseContent);
    return StringSerializationAPI.Deserialize<List<Tweet>>(responseContent);
    // var tweets = (object[])serializer.DeserializeObject(responseContent);

    // return tweets.Cast<Dictionary<string, object>>().Select(tweet =>
    // {
    //    var user = ((Dictionary<string, object>)tweet["user"]);
    //    var date = DateTime.ParseExact(tweet["created_at"].ToString(),
    //      "ddd MMM dd HH:mm:ss zz00 yyyy",
    //      CultureInfo.InvariantCulture).ToLocalTime();

    //    return new Tweet
    //    {
    //      Id = (long)tweet["id"],
    //      CreatedAt = date,
    //      Text = (string)tweet["text"],
    //      UserName = (string)user["name"],
    //      ScreenName = (string)user["screen_name"]
    //    };
    // }).ToArray();
  }

  public static OAuthInfo RequestToken(string consumerKey, string consumerSecret) {
    var oauth = new OAuthInfo {
      ConsumerKey = consumerKey,
      ConsumerSecret = consumerSecret
    };
    var builder = new RequestBuilder(oauth, "GET", "https://api.twitter.com/oauth/request_token")
      .AddParameter("oauth_callback", "oob"); // Out-of-band authentication
    var response = builder.Execute();
    // Debug.Log("requesttoken response " + response);
    oauth.AccessToken = Regex.Match(response, @"oauth_token=([^&]+)").Groups[1].Value;
    oauth.AccessSecret = Regex.Match(response, @"oauth_token_secret=([^&]+)").Groups[1].Value;
    if (string.IsNullOrEmpty(oauth.AccessSecret)
        || string.IsNullOrEmpty(oauth.AccessToken)) {
      throw new Exception("Could not find token or token secret in response: " + response);
    }
    return oauth;
  }


  public static AccessInfo AccessToken(string consumerKey, string consumerSecret, string requestToken, string pin) {
    var oauth = new OAuthInfo {
      ConsumerKey = consumerKey,
      ConsumerSecret = consumerSecret,
      AccessToken = requestToken
    };
    // Debug.Log("accesstoken start");
    var builder = new RequestBuilder(oauth, "POST", "https://api.twitter.com/oauth/access_token")
      .AddParameter("oauth_verifier", pin);
    var response = builder.Execute();
    // Debug.Log("accesstoken response " + response);

    var access = new AccessInfo
    {
      oauth = new OAuthInfo {
        ConsumerKey = consumerKey,
        ConsumerSecret = consumerSecret,
        AccessToken = Regex.Match(response, @"oauth_token=([^&]+)").Groups[1].Value,
        AccessSecret = Regex.Match(response, @"oauth_token_secret=([^&]+)").Groups[1].Value
      },
      user = new User {
        id = Convert.ToInt64(Regex.Match(response, @"user_id=([^&]+)").Groups[1].Value),
        screenName = Regex.Match(response, @"screen_name=([^&]+)").Groups[1].Value
      }
    };
    return access;
  }

  #region RequestBuilder

  public class RequestBuilder
  {
    private const string VERSION = "1.0";
    private const string SIGNATURE_METHOD = "HMAC-SHA1";

    private readonly OAuthInfo oauth;
    private readonly string method;
    private readonly IDictionary<string, string> customParameters;
    private readonly string url;

    public RequestBuilder(OAuthInfo oauth, string method, string url)
    {
      this.oauth = oauth;
      this.method = method;
      this.url = url;
      customParameters = new Dictionary<string, string>();
    }

    public RequestBuilder AddParameter(string name, string value)
    {
      customParameters.Add(name, value.EncodeRFC3986());
      return this;
    }

    public string Execute()
    {
      var timespan = GetTimestamp();
      var nonce = CreateNonce();

      var parameters = new Dictionary<string, string>(customParameters);
      AddOAuthParameters(parameters, timespan, nonce);

      var signature = GenerateSignature(parameters);
      var headerValue = GenerateAuthorizationHeaderValue(parameters, signature);

      var request = (HttpWebRequest)WebRequest.Create(GetRequestUrl());
      request.Method = method;
      request.ContentType = "application/x-www-form-urlencoded";

      request.Headers.Add("Authorization", headerValue);

      WriteRequestBody(request);

      string content;

      using ( var response = request.GetResponse() ) {
        using( var stream = response.GetResponseStream() ) {
          using( var reader = new StreamReader( stream ) ) {
            content = reader.ReadToEnd();
          }
        }
      }
      // Useful for debugging
      /*catch( WebException ex ) {

        using( var stream = ex.Response.GetResponseStream() ) {
        using( var reader = new StreamReader( stream ) ) {
        content = reader.ReadToEnd();
        }
        }
        throw;
        }*/
      // finally {
      //    if( response != null ) {
      //      ( (IDisposable)response ).Dispose();
      //    }
      // }

      return content;
    }

    public string MultipartExecute( byte[] bytes, int start = 0, int length = -1 )
    {
      var timespan = GetTimestamp();
      var nonce = CreateNonce();

      var parameters = new Dictionary<string, string>();
      AddOAuthParameters( parameters, timespan, nonce );

      // for multi-part requests, the signature is only generated over the oauth_ parameters
      var signature = GenerateSignature( parameters );
      var headerValue = GenerateAuthorizationHeaderValue( parameters, signature );

      var request = (HttpWebRequest)WebRequest.Create( GetRequestUrl() );
      request.Method = method;
      string boundary = "----------" + DateTime.Now.Ticks.ToString( "x" );
      request.ContentType = "multipart/form-data; boundary=" + boundary;

      request.Headers.Add( "Authorization", headerValue );
      string content = null;
      using ( Stream requestStream = request.GetRequestStream() ) {
        WriteMultipartRequestBody( requestStream, boundary, customParameters, bytes, start, length );

        // XXX This must be closed in Unity before calling GetResponse
        // otherwise it'll timeout.  That took awhile to find.
        requestStream.Close();
        using ( WebResponse response = request.GetResponse() ) {
          // var r = response as HttpWebResponse;
          // if (r != null) {
          //   Debug.Log("Status code " + (int)r.StatusCode);
          // } else {
          //   Debug.Log("Not a HttpWebResponse.");
          // }
          using( var stream = response.GetResponseStream() ) {
            using( var reader = new StreamReader( stream ) ) {
              content = reader.ReadToEnd();
            }
          }
        }
        // Useful for debugging
        /*catch( WebException ex ) {

          using( var stream = ex.Response.GetResponseStream() ) {
          using( var reader = new StreamReader( stream ) ) {
          content = reader.ReadToEnd();
          }
          }
          throw;
          }*/
        // finally {
        //    if( response != null ) {
        //      ( (IDisposable)response ).Dispose();
        //    }
        // }
      }
      return content;
    }

    private void WriteRequestBody(HttpWebRequest request)
    {
      if (method == "GET")
        return;

      var requestBody = Encoding.ASCII.GetBytes(GetCustomParametersString());
      using (var stream = request.GetRequestStream())
        stream.Write(requestBody, 0, requestBody.Length);
    }

    private string GetRequestUrl()
    {
      if (method != "GET" || customParameters.Count == 0)
        return url;

      return string.Format("{0}?{1}", url, GetCustomParametersString());
    }

    private string GetCustomParametersString()
    {
      return customParameters.Select(x => string.Format("{0}={1}", x.Key, x.Value)).Join("&");
    }

    private string GenerateAuthorizationHeaderValue(IEnumerable<KeyValuePair<string, string>> parameters, string signature)
    {
      return new StringBuilder("OAuth ")
        .Append(parameters.Concat(new KeyValuePair<string, string>("oauth_signature", signature))
                .Where(x => x.Key.StartsWith("oauth_"))
                .Select(x => string.Format("{0}=\"{1}\"", x.Key, x.Value.EncodeRFC3986()))
                .Join(","))
        .ToString();
    }

    private string GenerateSignature(IEnumerable<KeyValuePair<string, string>> parameters)
    {
      var dataToSign = new StringBuilder()
        .Append(method).Append("&")
        .Append(url.EncodeRFC3986()).Append("&")
        .Append(parameters
                .OrderBy(x => x.Key)
                .Select(x => string.Format("{0}={1}", x.Key, x.Value))
                .Join("&")
                .EncodeRFC3986());

      var signatureKey = string.Format("{0}&{1}", oauth.ConsumerSecret.EncodeRFC3986(), oauth.AccessSecret.EncodeRFC3986());
      var sha1 = new HMACSHA1(Encoding.ASCII.GetBytes(signatureKey));

      var signatureBytes = sha1.ComputeHash(Encoding.ASCII.GetBytes(dataToSign.ToString()));
      return Convert.ToBase64String(signatureBytes);
    }

    private void AddOAuthParameters(IDictionary<string, string> parameters, string timestamp, string nonce)
    {
      parameters.Add("oauth_version", VERSION);
      parameters.Add("oauth_consumer_key", oauth.ConsumerKey);
      parameters.Add("oauth_nonce", nonce);
      parameters.Add("oauth_signature_method", SIGNATURE_METHOD);
      parameters.Add("oauth_timestamp", timestamp);
      parameters.Add("oauth_token", oauth.AccessToken);
    }

    private static string GetTimestamp()
    {
      return ((int)(DateTime.UtcNow - new DateTime(1970, 1, 1)).TotalSeconds).ToString();
    }

    private static string CreateNonce()
    {
      return new System.Random().Next(0x0000000, 0x7fffffff).ToString("X8");
    }

    private static void WriteMultipartRequestBody( Stream requestStream, string boundary, IDictionary<string, string> parameters, byte[] fileData, int start = 0, int length = -1) {
      byte[]  boundarybytes = Encoding.ASCII.GetBytes( "--" + boundary + "\r\n" );
      byte[]  trailer = Encoding.ASCII.GetBytes( "\r\n--" + boundary + "--\r\n" );
      byte[]  temp = null;

      if( parameters != null ) {
        foreach( string key in parameters.Keys ) {

          requestStream.Write( boundarybytes, 0, boundarybytes.Length );
          temp = Encoding.ASCII.GetBytes( string.Format( "Content-Disposition: form-data; name=\"{0}\"\r\n\r\n{1}", key, parameters[ key ] ) );
          requestStream.Write( temp, 0, temp.Length );
          temp = Encoding.ASCII.GetBytes( "\r\n" );
          requestStream.Write( temp, 0, temp.Length );
        }
      }

      //Getting this right is tricky, multipart requests will just end up with "media not found" errors when not done properly
      requestStream.Write( boundarybytes, 0, boundarybytes.Length );
      temp = Encoding.ASCII.GetBytes( string.Format( "Content-Disposition: form-data; name=\"{0}\"; filename=\"{1}\";\r\n", "media", "hi" ) );
      requestStream.Write( temp, 0, temp.Length );

      // documentation says this is required, but I've seen it work just fine without it
      temp = Encoding.ASCII.GetBytes( "Content-Type: application/octet-stream\r\n\r\n" );
      requestStream.Write( temp, 0, temp.Length );

      requestStream.Write( fileData, start, length < 0 ? fileData.Length : length );
      requestStream.Write( trailer, 0, trailer.Length );
    }
  }

  #endregion
}

public static class TinyTwitterHelperExtensions
{
  public static string Join<T>(this IEnumerable<T> items, string separator)
  {
    return string.Join(separator, items.Select(x => x.ToString()).ToArray());
  }

  public static IEnumerable<T> Concat<T>(this IEnumerable<T> items, T value)
  {
    return items.Concat(new[] { value });
  }

  public static string EncodeRFC3986(this string value)
  {
    // From Twitterizer http://www.twitterizer.net/

    if (string.IsNullOrEmpty(value))
    {
      return string.Empty;
    }

    int limit = 20000;

    //Handle very large strings, Uri.EscapeDataString has a max length of 32766
    // so we'll look at this in chunks and append it all together
    StringBuilder sb = new StringBuilder(value.Length);
    int loops = value.Length / limit;

    for(int i = 0; i <= loops; i++)
    {
      if(i < loops)
      {
        sb.Append(Uri.EscapeDataString(value.Substring(limit * i, limit)));
      }
      else
      {
        sb.Append(Uri.EscapeDataString(value.Substring(limit * i)));
      }
    }

    var encoded = sb.ToString();

    return Regex
      .Replace(encoded, "(%[0-9a-f][0-9a-f])", c => c.Value.ToUpper())
      .Replace("(", "%28")
      .Replace(")", "%29")
      .Replace("$", "%24")
      .Replace("!", "%21")
      .Replace("*", "%2A")
      .Replace("'", "%27")
      .Replace("%7E", "~");
  }
}

public class TwitterDateTimeConverter : fsDirectConverter {
  public override Type ModelType { get { return typeof(DateTime); } }

  public override object CreateInstance(fsData data, Type storageType) {
    return new DateTime();
  }

  public override fsResult TrySerialize(object instance, out fsData serialized, Type storageType) {
    serialized = new fsData(((DateTime)instance).ToString());
    return fsResult.Success;
  }

  public override fsResult TryDeserialize(fsData data, ref object instance, Type storageType) {
    if (! data.IsString) return fsResult.Fail("Expected string in " + data);

    // https://stackoverflow.com/questions/14962803/json-date-from-tweeter-to-c-sharp-format
    // var twitterTimeformat = "ddd MMM dd HH:mm:ss zzz yyyy";
    //                       Sat Jun 17 04:03:19 +0000 2017
    var twitterTimeformat = "ddd MMM dd HH:mm:ss +ffff yyyy";
    // Debug.Log("data = " + data.AsString);
    instance = DateTime.ParseExact(data.AsString,
                                   twitterTimeformat,
                                   CultureInfo.InvariantCulture,
                                   DateTimeStyles.AdjustToUniversal).ToLocalTime();
    // instance = DateTime.Parse(data.AsString);
    return fsResult.Success;
  }
}

}
